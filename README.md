# LFUCache Project

В этой работе реализованы два вида кэша:

1. **LFUCache** – кэш с алгоритмом **Least Frequently Used** (наименее часто используемые элементы вытесняются).
2. **IdealCache** – идеальный кэш (алгоритм Белади), используется для сравнения эффективности LFU.

---

## Сборка и запуск проекта

```bash
git clone https://github.com/I1Va/LFUCache.git

cmake -B build
cmake --build build

./build/LFUCache
```

---

## Использование программы

1. Введите **емкость кэша**.
2. Вводите последовательность **ключей-запросов** (integer), которые хотите получить из кэша.

Пример ввода:

```
Enter cache capacity : 3
Enter queries (Ctrl+D to end): 
1
cache miss!
2
cache miss!
1
3
cache miss!
2
1
Count of queries    : 6
Count of cache hits : 3
```

* Для завершения ввода нажмите `Ctrl + D`.
* Программа выведет количество попаданий в кэш (hits) для LFU и общее количество запросов.

---

## Тестирование
Тесты находятся в папке tests/Test.cpp


Запуск всех тестов
```bash
./build/tests/tests
```

---
## Реализация LFUCache

LFUCache хранит данные с учетом частоты использования. Основные структуры:

* `hashTable_` – быстрый доступ к элементам по ключу (`O(1)` поиск).
* `freqTable_` – список резидентов(ячеек данных, которые находятся в кэше на данный момент) для каждой частоты; каждый список содержит уникальные элементы.
* `minFreq_` – текущая минимальная частота для быстрого поиска кандидата на вытеснение.

**Алгоритм работы:**

1. При обращении к элементу:

   * Если элемент есть в `hashTable_` → **hit**:

     * Увеличиваем его частоту.
     * Переносим в соответствующий список `freqTable_` с новой частотой.
   * Если элемента нет → **miss**:

     * Если кэш не полон → добавляем новый элемент с частотой 0.
     * Если кэш полон → вытесняем элемент с минимальной частотой (`minFreq_`), вставляем новый.

**Пример использования LFUCache:**

```cpp
cache::LFUCache<test::Page> lfuCache(3);
lfuCache.lookupUpdate(1, test::slowGetPage); // miss
lfuCache.lookupUpdate(2, test::slowGetPage); // miss
lfuCache.lookupUpdate(1, test::slowGetPage); // hit
```

---

## Реализация IdealCache

IdealCache реализует **алгоритм Белади** – вытесняет тот элемент, чей **следующий доступ будет максимально отдалённым в будущем**.

Основные структуры:

* `queryTable_` – очередь индексов всех будущих запросов для каждого ключа.
* `keyQueue_` – приоритетная очередь ключей по следующему индексу запроса (для выбора элемента на вытеснение).
* `hashTable_` и `cache_` – аналогично LFUCache, хранят текущие элементы кэша.

**Алгоритм работы:**

1. При обращении к элементу:

   * Если элемент есть в `hashTable_` → **hit**, обновляем его `keyQueue_` с индексом следующего запроса.
   * Если элемента нет → **miss**:

     * Если кэш не полон → добавляем элемент.
     * Если кэш полон → вытесняем элемент с **максимальной задержкой до следующего запроса**, вставляем новый элемент.
