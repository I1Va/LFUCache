# LFUCache Project

В этой работе реализованы два вида кэша:

1. **LFUCache** – кэш с алгоритмом **Least Frequently Used** (наименее часто используемые элементы вытесняются).
2. **BeladyCache** – идеальный кэш (алгоритм Белади), используется для сравнения эффективности LFU.

---

## Сборка

```bash
git clone https://github.com/I1Va/LFUCache.git
cd LFUCache

cmake -B build
cmake --build build
```

---

## Использование программы
Запуск Belady cache:
```bash
./build/Belady
```

Запуск LFU cache:
```bash
./build/LFU
```

---

## Тестирование
Запуск всех тестов
```bash
cd ./build/tests && ctest
```

---
## Реализация LFUCache

LFUCache хранит данные с учетом частоты использования. Основные структуры:

* `hashTable_` – быстрый доступ к элементам по ключу (`O(1)` поиск).
* `freqTable_` – список резидентов(ячеек данных, которые находятся в кэше на данный момент) для каждой частоты; каждый список содержит уникальные элементы.
* `minFreq_` – текущая минимальная частота для быстрого поиска кандидата на вытеснение.

**Алгоритм работы:**

1. При обращении к элементу:

   * Если элемент есть в `hashTable_` → **hit**:

     * Увеличиваем его частоту.
     * Переносим в соответствующий список `freqTable_` с новой частотой.
   * Если элемента нет → **miss**:

     * Если кэш не полон → добавляем новый элемент с частотой 0.
     * Если кэш полон → вытесняем элемент с минимальной частотой (`minFreq_`), вставляем новый.

**Пример использования LFUCache:**

```cpp
cache::LFUCache<test::Page, int> lfuCache(3);
lfuCache.lookupUpdate(1, test::slowGetPage); // miss
lfuCache.lookupUpdate(2, test::slowGetPage); // miss
lfuCache.lookupUpdate(1, test::slowGetPage); // hit
```

---

## Реализация BeladyCache

BeladyCache реализует **алгоритм Белади** – вытесняет тот элемент, чей **следующий доступ будет максимально отдалённым в будущем**.

Основные структуры:

* `queryTable_` – очередь индексов всех будущих запросов для каждого ключа.
* `keyQueue_` – приоритетная очередь ключей по следующему индексу запроса (для выбора элемента на вытеснение).
* `hashTable_` и `cache_` – аналогично LFUCache, хранят текущие элементы кэша.

**Алгоритм работы:**

1. При обращении к элементу:

   * Если элемент есть в `hashTable_` → **hit**, обновляем его `keyQueue_` с индексом следующего запроса.
   * Если элемента нет → **miss**:

     * Если кэш не полон → добавляем элемент.
     * Если кэш полон → вытесняем элемент с **максимальной задержкой до следующего запроса**, вставляем новый элемент.
